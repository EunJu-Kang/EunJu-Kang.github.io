---
layout: post
title:  "ACM Craft"
subtitle:   "1005"
categories: Algorithm
tags: BOJ
---

## 백준 [1005] ACM Craft
[문제보기](https://www.acmicpc.net/problem/1005) <br>
![Alt text](/assets/img/baekjoon/1005.PNG)

### 풀이
건설하고자 하는 건물의 사전 건물들의 건설 시간을 탐색한다. 이미 확인된 건물의 시간은 탐색하지 않고 사전에 탐색한 시간을 활용한다.
- 참고1 : 건물을 짓는 시간이 모두 0초 인 경우를 고려하여 건설 여부를 -1로 세팅한다. 0초로 세팅하는 경우 무한루프를 돌아 시간초과 발생
- 참고2 : 이번 풀이에서는 `메모이제이션 + dfs`를 활용하여 문제를 풀이하였지만, 순서 결정해주는 '위상정렬' 알고리즘을 활용하여 풀이할 수 있다


### 소스코드

~~~ java
import java.util.*;

public class Main {
    public static void main(String[] agrs) {
        Scanner sc = new Scanner(System.in);

        int T = sc.nextInt();
        for (int tc = 0; tc < T; tc++) {
            int N = sc.nextInt(); // 건물의 갯수
            int K = sc.nextInt(); // 건설 규칙 갯수

            // 건물 별 건설 시간
            int[] D = new int[N];
            for (int i = 0; i < N; i++) {
                D[i] = sc.nextInt();
            }

            // 건물 순서 규칙 입력 (key : 건물 번호, value: 건물이 지어지기 위해 사전에 지어져야하는 건물들)
            Map<Integer, List<Integer>> roleMap = new HashMap<>();
            for (int xy = 0; xy < K; xy++) {
                int x = sc.nextInt() - 1;
                int y = sc.nextInt() - 1;

                roleMap.computeIfAbsent(y, key -> new ArrayList<>()).add(x);
            }

            int W = sc.nextInt() - 1; // 건설하고자 하는 건물 번호

            int[] buildTime = new int[N];
            Arrays.fill(buildTime, -1);

            int buildingTime = getBuildingTime(roleMap, D, buildTime, W);
            System.out.println(buildingTime);
        }
    }

    private static int getBuildingTime(Map<Integer, List<Integer>> roleMap, int[] D, int[] buildTime, int currentNo) {
        // 건물의 시작점에 도달한 경우
        if (!roleMap.containsKey(currentNo)) {
            buildTime[currentNo] = D[currentNo];
            return buildTime[currentNo];
        }

        // 건물이 이미 지어진 경우
        if (buildTime[currentNo] != -1) {
            return buildTime[currentNo];
        }

        List<Integer> beforeBuildings = roleMap.get(currentNo);
        int maxBeforeBuildTime = 0;

        for (int beforeNo : beforeBuildings) {
            // 아직 사전 건물의 시간을 모르는 경우
            if (buildTime[beforeNo] == -1) {
                buildTime[beforeNo] = getBuildingTime(roleMap, D, buildTime, beforeNo);
            }

            maxBeforeBuildTime = Math.max(maxBeforeBuildTime, buildTime[beforeNo]);
        }

        buildTime[currentNo] = maxBeforeBuildTime + D[currentNo];

        return buildTime[currentNo];
    }
}
~~~
